{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
module MIML.Abs (Tree(..), Exp, johnMajorEq, module MIML.ComposOp) where

import MIML.ComposOp

import Data.Monoid (mappend)


-- Haskell module generated by the BNF converter

data Tag = Exp_
type Exp = Tree Exp_

data Tree :: Tag -> * where
    EAdd :: Exp -> Exp -> Tree Exp_
    ESub :: Exp -> Exp -> Tree Exp_
    EMul :: Exp -> Exp -> Tree Exp_
    EDiv :: Exp -> Exp -> Tree Exp_
    EInt :: Integer -> Tree Exp_

instance Compos Tree where
  compos r a f t = case t of
      EAdd exp0 exp1 -> r EAdd `a` f exp0 `a` f exp1
      ESub exp0 exp1 -> r ESub `a` f exp0 `a` f exp1
      EMul exp0 exp1 -> r EMul `a` f exp0 `a` f exp1
      EDiv exp0 exp1 -> r EDiv `a` f exp0 `a` f exp1
      _ -> r t

instance Show (Tree c) where
  showsPrec n t = case t of
    EAdd exp0 exp1 -> opar n . showString "EAdd" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    ESub exp0 exp1 -> opar n . showString "ESub" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    EMul exp0 exp1 -> opar n . showString "EMul" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    EDiv exp0 exp1 -> opar n . showString "EDiv" . showChar ' ' . showsPrec 1 exp0 . showChar ' ' . showsPrec 1 exp1 . cpar n
    EInt integer -> opar n . showString "EInt" . showChar ' ' . showsPrec 1 integer . cpar n
   where opar n = if n > 0 then showChar '(' else id
         cpar n = if n > 0 then showChar ')' else id

instance Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> Bool
johnMajorEq (EAdd exp0 exp1) (EAdd exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (ESub exp0 exp1) (ESub exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (EMul exp0 exp1) (EMul exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (EDiv exp0 exp1) (EDiv exp0_ exp1_) = exp0 == exp0_ && exp1 == exp1_
johnMajorEq (EInt integer) (EInt integer_) = integer == integer_
johnMajorEq _ _ = False

instance Ord (Tree c) where
  compare x y = compare (index x) (index y) `mappend` compareSame x y
index :: Tree c -> Int
index (EAdd _ _) = 0
index (ESub _ _) = 1
index (EMul _ _) = 2
index (EDiv _ _) = 3
index (EInt _) = 4
compareSame :: Tree c -> Tree c -> Ordering
compareSame (EAdd exp0 exp1) (EAdd exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (ESub exp0 exp1) (ESub exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (EMul exp0 exp1) (EMul exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (EDiv exp0 exp1) (EDiv exp0_ exp1_) = mappend (compare exp0 exp0_) (compare exp1 exp1_)
compareSame (EInt integer) (EInt integer_) = compare integer integer_
compareSame x y = error "BNFC error:" compareSame
